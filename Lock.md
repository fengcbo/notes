# 锁的实现

## Lock

### class doc

Lock 实现提供了比 synchronized方法和语句 更广泛的锁的操作。它允许更灵活的结构，拥有相差很大的属性，并且支持多个相关的 Condition 对象。

锁是针对多线程访问共享资源的控制工具。通常，锁提供了对共享资源的排他访问：同一时间只允许一个线程获取锁，并且所有对共享资源的访问必须首先获取锁。
然而，有一些锁允许并发访问共享资源，比如 ReadWriteLock的读锁。

synchronized 方法和语句提供了对每个对象相关的隐士监视器锁的访问，但是强制所有的锁的获取和释放均通过块结构的方式：
当多个锁被获取时，它们必须通过相反的顺序释放，并且所有的锁 必须在与获取锁相同的作用域内 释放。

虽然 synchronized方法和语句的范围机制使得监视器锁编程更简单，而且帮助避免了涉及锁的常见编程错误，
但是有时你仍然需要以更加灵活的方式来使用锁。比如，并发遍历数据结构的算法需要"hand-over-hand"或者"chain locking"的使用方式：
先获取A节点的锁，然后获取B节点，然后释放A节点并且获取C节点，然后释放B节点并且获取D节点等等。
Lock接口的实现 通过允许在不用作用域获取和释放锁并且允许通过任意顺序来获取和释放多个锁 来支持这种使用方式。

更高的灵活性也带来的额外的责任。没有块结构的锁删除了synchronized方法和语句的自动释放锁功能。大部分场景下，应该使用一下语句：

```
Lock l = ...;
l.lock();
try {
  // access the resource protected by this lock
} finally {
  l.unlock();
}}
```

当锁的获取和释放发生在不用方位，需要谨慎的确保 保持锁的所有执行代码通过 try-finally 或 try-catch 加以保护，已确保锁能够在必要的时候释放。

Lock 实现提供了synchronized方法和语句所没有的功能，包括非阻塞锁的获取(#tryLock())、可中断锁的获取(#lockInterruptibly()) 以及 超时锁的获取(#tryLock(long, TimeUnit))。

Lock还可以提供与隐式监视器锁不同的行为和语义，比如保证排序、非重入用法 或者 死锁检测。如果某个实现提供了这样特殊的语义，则该实现必须将这些语义加以记录。

```
注意：Lock只是一个普通对象，他们可以在synchronized语句中当做目标对象使用。获取Lock实例的监视器锁与执行该实例的任意lock方式没有特殊的联系。
为了避免混淆，推荐不要以这种方式使用Lock对象，除非在他们的内部实现中。
```

#### 内存同步

所有的Lock实现确保与内置的监视器锁提供相同的内存同步语义， 如[The Java Language Specification (17.4 Memory Model)](https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4)所描述的

- Lock的成功lock操作与监视器的成功Lock操作拥有相同的内存同步语义。
- Lock的成功unlock操作与监视器的成功Unlock操作拥有相同的内存同步语义。

不成功的锁获取和或释放以及可重入锁的获取和释放没有任何内存语义。


#### 实现的注意事项

三种形式锁的获取(可中断、不可中断和超时)在其性能特征、排序保证或者其他实现质量上会有所不同。而且，对于给定的Lock类，可能没有中断正在进行的锁获取的能力。
因此，并不要求实现为所有三种形式的锁获取定义相同的保证或语义，也不要求其支持中断正在进行的锁获取。实现必需清楚地对每个锁定方法所提供的语义和保证进行记录。
还必须遵守此接口中定义的中断语义，以便为锁获取中断提供支持：完全支持中断，或仅在进入方法时支持中断。

由于中断通常意味着取消而且中断检测并不常见，因此，相对于普通方法返回而言，实现可能更喜欢响应某个中断。即使出现在另一个操作后的中断可能会释放线程锁时也是如此。实现应记录此行为。

### lock() 获取锁

如果锁不可用，出于线程调度的目的，当前线程将被禁用，并且进入休眠状态，直到锁获取成功

#### 实现注意事项

Lock的实现可能能够检测到锁的错误使用，比如可能带来死锁的操作，在那种情况下可能会抛出unchecked异常。Lock实现必须对环境和异常类型进行记录。

### lockInterruptibly() 获取可中断锁

获取锁除非当前线程被中断(Thread#interrupt)

如果锁可用，则获取锁，并立刻返回

如果锁不可用，出于线程调度目的，当前线程将被禁用，并进入休眠状态，直到发生以下两种情况中的一种：

- 当前线程获取锁成功
- 其他线程中断了当前线程，并且支持对中断对锁的获取

如果当前线程

- 在进入这个方法时设置了当前线程的中断状态，或者
- 在获取锁时被中断，并且支持对锁获取的中断

则将抛出InterruptedException异常，并且当前线程的中断状态将被清除。

#### 实现注意事项

在一些实现中可能无法中断锁的获取，即使可以，该操作开销也很大。开发者应该清除这种情况。实现需要对这种情况进行标注。

相对于普通方法的返回，实现可能更倾向于响应中断。

Lock的实现需要能够检测错误的使用，不如可能带来死锁的操作，并且在某些场景下可能抛出unchecked异常。Lock的实现必须记录这些场景和异常类型。


### tryLock() 仅在锁空闲时获取锁

在调用的时候锁是空闲的才获取锁。

如果锁可用，则获取锁，并且立即返回true。
如果锁不可用，方法立即返回false。

这个方法的经典实用方式如下：

```
Lock lock = ...;
if (lock.tryLock()) {
  try{
    // manipulate protected state(操作受保护的状态)
  }finally {
    lock.unlock();
  }
}else{
  // perform alternative actions(执行其他操作)
}
```

这种方式可确保如果获取了锁就去解锁，如果没有获取锁，则不会尝试释放。


### tryLock(long time, TimeUnit unit) 获取超时锁

如果锁在给定时间内空闲，并且当前线程没有被中断，则获取锁

如果锁可用，当前方法立即返回true

如果锁不可用，出于线程调度目的，当前线程将被禁用，并进入休眠状态，直到发生以下三种情况中的一种：

- 当前线程获取到锁
- 其他线程中断了当前线程，并且支持对所锁获取的中断
- 超过了指定时间

如果获得了锁，则返回true

如果当前线程：

- 在进入这个方法时设置了当前线程的中断状态，或者
- 在获取锁时被中断，并且支持对锁获取的中断，或者

则将抛出InterruptedException异常，并且当前线程的中断状态将被清除。


如果超过了指定时间，则返回false。如果time小于等于0，该方法将不再等待。

#### 实现注意事项

在一些实现中可能无法中断锁的获取，即使可以，该操作开销也很大。开发者应该清除这种情况。实现需要对这种情况进行标注。

相对于普通方法的返回，实现可能更倾向于响应中断。

Lock的实现需要能够检测错误的使用，不如可能带来死锁的操作，并且在某些场景下可能抛出unchecked异常。Lock的实现必须记录这些场景和异常类型。


### unlock() 释放锁

释放锁

#### 实现注意事项

Lock 实现通常对哪个线程可以释放锁施加了限制(通常只有锁的保持着可以释放它)，如果违背了这个限制，可能会抛出unchecked异常。 该 Lock实现必须对所有的限制和异常类型进行记录。

### newCondition() 获取绑定到锁对象的Condition实例

返回一个新的绑定到当前Lock实例的Condition实例

在等待条件前，锁必须由当前线程持有。调用 Condition#await() 将在等待前以原子方式释放锁，并且在wait返回前重新获取锁。

#### 实现注意事项

Condition 实例的精确操作依赖于Lock的实现，并且该实现必须对此加以记录。
