# 响应式编程-Reactor核心特性值Threading

Flux和Mono都不会创建线程。类似publishOn的一些操作符会创建线程。并且，作为一种工作共享的机制，这些操作符会从其他work池中“偷”线程，如果其他work池目前是闲置状态。因此，无论是Flux还是Mono对象还是Subscriber对象都不必对线程很敏感。它们依赖操作符来管理线程和work池。



publishOn强制下一个操作(也有可能是随后的操作)运行在不同的线程中。与之类似，subscribeOn强制前一个操作(也有可能是之前的操作)运行在不同的线程中。记住，在你订阅subscribe之前，你只是定义了一个过程但是没有启动它。因此，反应器可以使用这些规则来确定处理过程必须如何进行。然后，当你订阅subscribe后，整个处理才开始工作。



考虑一个示例，该示例显示多个线程可以支持工作共享：

```java
Flux.range(1, 10000) ①
    .publishOn(Schedulers.parallel()) ②
    .subscribe(result) ③
```



①创建一个包含Flux元素的Flux

②创建和CPU数量相同的线程(最小为4)

③在你订阅之前，什么也不会发生。



`Schedulers.parallel()` 创建一个固定大小的基于单线程ExecutorService的工作池。由于一个或两个可能会导致问题，所以它最少创建四个线程。publishOn会共享这些线程工作者，当publishOn请求元素时，从其他线程拿到元素并发布。以这种方式，我们获得工作共享(资源共享的一种形式)。反应器还支持其他几种共享资源的方式，如在 [Schedulers](./响应式编程-7Reactor核心特性之Schedulers.md) 中记录的那样。



`Schedulers.elastic()`也会创建线程，它以一种简便的方式创建专用线程来包装阻塞资源(例如同步调用)。



在幕后，operators通过使用增量计数器和保护条件来确保线程安全。例如，如果我们有四个线程访问一个流(如前面的示例所示)，那么每个请求都会增加一个计数器，以便来自线程的请求获得正确的项。